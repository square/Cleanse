//
//  main.swift
//  Cleanse
//
//  Created by holmes on 6/28/17.
//  Copyright Â© 2017 Square, Inc. All rights reserved.
//

import Foundation

let maxArities = 21

struct GenerateBindersArities {
    static func build(path: String) {
        let start = "/// DO NOT EDIT - This file was auto-generated by CleanseGen/main.swift\n"
            .appending("extension BindToable {\n\n")

        let contents = (1..<maxArities)
            .reduce(start) { $0.appending(make(arity: $1)) }
            .appending("}\n")

        do {
            try contents.write(toFile: path, atomically: false, encoding: .utf8)
        } catch let error as NSError {
            print("Ooops! Something went wrong: \(error)")
        }
    }

    private static func make(arity: Int) -> String {
        let paramIndexes = 1...arity
        let sourceInfoArguments = "file: StaticString=#file, line: Int=#line, function: StaticString=#function"

        var contents = ""
        contents += "/// \(arity)-arity `to(factory:)` function.\n"
        contents += "/// This completes the binding process for registering the provider for the type passed (or inferred) to `bind()`.\n"
        contents += "/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function\n"
        contents += "///\n"
        contents += "/// - Note: This method was auto-generated by CleanseGen/main.swift\n"

        contents += "@discardableResult public func to<\(paramIndexes.map { "P_\($0)" }.joined(separator: ", "))>"
            + "(\(sourceInfoArguments), factory: @escaping (\(paramIndexes.map { "P_\($0)" }.joined(separator: ", "))) -> Input)  -> BindingReceipt<Input> {\n"

        contents += "    let binder = self.binder, finalBindingType = self._finalProviderType as! AnyProvider.Type\n"
        for i in paramIndexes {
            contents += "    let provider\(i) = binder.provider(P_\(i).self, file: file, line: line, function: function, providerRequiredFor: finalBindingType)\n"
        }

        contents += "\n"
        contents += "    return _innerTo(file: file, line: line, function: function, provider: Provider {\n     factory(\n        \(paramIndexes.map { "provider\($0).get()" }.joined(separator: ",\n        "))\n    )\n   })\n"
        contents += "}\n\n"

        return contents
    }
}

struct GeneratePropertyInjectionArities {
    static func build(path: String) {
        let start = "/// DO NOT EDIT - This file was auto-generated by CleanseGen/main.swift\n"
            .appending("extension PropertyInjectorBindingBuilderProtocol {\n\n")

        let staticVariants = (1..<maxArities)
            .reduce("") { $0.appending(make(arity: $1, instanceVariant: false)) }

        let instanceVariants = (1..<maxArities)
            .reduce("") { $0.appending(make(arity: $1, instanceVariant: true)) }

        do {
            let content = start
                .appending(staticVariants)
                .appending(instanceVariants)
                .appending("}\n\n")

            try content.write(toFile: path, atomically: false, encoding: .utf8)
        } catch let error as NSError {
            print("Ooops! Something went wrong: \(error)")
        }
    }

    private static func make(arity: Int, instanceVariant: Bool) -> String {
        let paramIndexes = 1...arity

        let sourceInfoArguments = "file: StaticString=#file, line: Int=#line, function: StaticString=#function"
        let piSigFirstPart = instanceVariant ? "(Element," : "(Element) -> ("

        var content = ""

        if instanceVariant {
            content += "/// \(arity)-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> ()` function.\n"
            content += "/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.\n"
            content += "/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```\n"
            content += "/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e\n"
        } else {
            content += "/// \(arity)-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> ()` function.\n"
            content += "/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.\n"
            content += "/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`\n"
            content += "/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```\n"
            content += "/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function\n"
        }

        content += "///\n"
        content += "/// - Note: This method was generated by `\((#file as String).components(separatedBy: "/").last!)`\n"
        content += "@discardableResult public func to<\(paramIndexes.map { "P_\($0)" }.joined(separator: ", "))>"
            + "(\(sourceInfoArguments), injector: @escaping \(piSigFirstPart)\(paramIndexes.map { "P_\($0)" }.joined(separator: ", "))) -> ()) -> BindingReceipt<PropertyInjector<Element>> {\n"

        content += "let binder = self.binder\n"
        for i in paramIndexes {
            content += "    let provider\(i) = binder.provider(P_\(i).self, file: file, line: line, function: function, providerRequiredFor: Element.self)\n"
        }
        content += "\n"

        let piFirstPart: String = instanceVariant ? "injector(\n$0," : "injector($0)(\n"

        let propertyInjectorCall = "\(piFirstPart)\n        \(paramIndexes.map { "provider\($0).get()" }.joined(separator: ",\n        ")))\n"

        content += "    return innerTo(propertyInjector: {\n"
        content += propertyInjectorCall
        content += "}, file: file, line: line, function: function)\n"
        content += "}\n"

        return content
    }
}

GenerateBindersArities.build(path: "./Cleanse/BinderArities.swift")
GeneratePropertyInjectionArities.build(path: "./Cleanse/PropertyInjectionArities.swift")
