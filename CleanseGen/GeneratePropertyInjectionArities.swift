//
//  GenerateBinders.swift
//  Cleanse
//
//  Created by Mike Lewis on 4/22/16.
//  Copyright Â© 2016 Square, Inc. All rights reserved.
//

import Foundation


#if !swift(>=3.0)
    extension String {
        /// Backwards-compatible swift 2.2 shim
        @warn_unused_result
        func components(separatedBy separator: String) -> [String] {
            return self.componentsSeparatedByString(separator)
        }
    }
    
#endif


func makeBinder(arity: Int, swift3: Bool, instanceVariant: Bool) {
    let paramIndexes = 1...arity
    
    
    let sourceInfoArguments: String
    
    if !swift3 {
        sourceInfoArguments = "file file: StaticString=#file, line: Int=#line, function: StaticString=#function"
    } else {
        sourceInfoArguments = "file: StaticString=#file, line: Int=#line, function: StaticString=#function"
    }

    let piSigFirstPart = instanceVariant ? "(Element," : "(Element) -> ("
    
    if instanceVariant {
        print("/// \(arity)-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> ()` function.")
        print("/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.")
        print("/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```")
        print("/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e")
    } else {
        print("/// \(arity)-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> ()` function.")
        print("/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.")
        print("/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`")
        print("/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```")
        print("/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function")
        
    }
    print("///")
    print("/// - Note: This method was generated by `\((#file as String).components(separatedBy: "/").last!)`")
    print("public func to<\(paramIndexes.map { "P_\($0)" }.joinWithSeparator(", "))>"
        + "(\(sourceInfoArguments), injector: \(piSigFirstPart)\(paramIndexes.map { "P_\($0)" }.joinWithSeparator(", "))) -> ()) -> BindingReceipt<PropertyInjector<Element>> {")
    
    print("let binder = self.binder")
    for i in paramIndexes {
        print("    let provider\(i) = binder.provider(P_\(i).self, file: file, line: line, function: function, providerRequiredFor: Element.self)")
    }
    print()
    
    let piFirstPart: String = instanceVariant ? "injector(\n$0," : "injector($0)(\n"
    
    let propertyInjectorCall = "\(piFirstPart)\n        \(paramIndexes.map { "provider\($0).get()" }.joinWithSeparator(",\n        ")))"
    
    print("    return innerTo(propertyInjector: {")
    print(propertyInjectorCall)
    print("}, file: file, line: line, function: function)")
    print("}")

}

let maxArities = 20

for instanceVariant in [false, true] {
    
    print("extension PropertyInjectorBindingBuilderProtocol {")
    print("#if swift(>=3.0)")
    (1..<maxArities).forEach { makeBinder($0, swift3: true, instanceVariant: instanceVariant) }
    print("#else")
    (1..<maxArities).forEach { makeBinder($0, swift3: false, instanceVariant: instanceVariant) }
    
    print("#endif")
print("}")

}

